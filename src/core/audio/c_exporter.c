#include "c_exporter.h"
#include "sequencer.h"
#include "synth.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *waveform_to_audio_out_type(enum waveform_type waveform)
{
	switch (waveform) {
	case WAVEFORM_SINE:
		return "AUDIO_OUT_TYPE_SINE";
	case WAVEFORM_SQUARE:
		return "AUDIO_OUT_TYPE_SQUARE";
	case WAVEFORM_TRIANGLE:
		return "AUDIO_OUT_TYPE_TRIANGE";  // Note: typo in badge firmware
	case WAVEFORM_SAWTOOTH:
		return "AUDIO_OUT_TYPE_SAWTOOTH";
	case WAVEFORM_NES_NOISE:
		return "AUDIO_OUT_TYPE_NES_NOISE";
	default:
		return "AUDIO_OUT_TYPE_SINE";
	}
}

static const char *get_note_macro(float frequency)
{
	int freq = (int)(frequency + 0.5f);

	switch (freq) {
	case 0:
		return "NOTE_REST";
	case 110:
		return "NOTE_A2";
	case 117:
		return "NOTE_As2";
	case 123:
		return "NOTE_B2";
	case 131:
		return "NOTE_C3";
	case 139:
		return "NOTE_Cs3";
	case 147:
		return "NOTE_D3";
	case 156:
		return "NOTE_Ds3";
	case 165:
		return "NOTE_E3";
	case 175:
		return "NOTE_F3";
	case 185:
		return "NOTE_Fs3";
	case 196:
		return "NOTE_G3";
	case 208:
		return "NOTE_Gs3";
	case 220:
		return "NOTE_A3";
	case 233:
		return "NOTE_As3";
	case 247:
		return "NOTE_B3";
	case 262:
		return "NOTE_C4";
	case 277:
		return "NOTE_Cs4";
	case 294:
		return "NOTE_D4";
	case 311:
		return "NOTE_Ds4";
	case 330:
		return "NOTE_E4";
	case 349:
		return "NOTE_F4";
	case 370:
		return "NOTE_Fs4";
	case 392:
		return "NOTE_G4";
	case 415:
		return "NOTE_Gs4";
	case 440:
		return "NOTE_A4";
	case 466:
		return "NOTE_As4";
	case 494:
		return "NOTE_B4";
	case 523:
		return "NOTE_C5";
	case 554:
		return "NOTE_Cs5";
	case 587:
		return "NOTE_D5";
	case 622:
		return "NOTE_Ds5";
	case 659:
		return "NOTE_E5";
	case 698:
		return "NOTE_F5";
	case 740:
		return "NOTE_Fs5";
	case 784:
		return "NOTE_G5";
	case 831:
		return "NOTE_Gs5";
	case 880:
		return "NOTE_A5";
	case 932:
		return "NOTE_As5";
	case 988:
		return "NOTE_B5";
	case 1047:
		return "NOTE_C6";
	case 1109:
		return "NOTE_Cs6";
	case 1175:
		return "NOTE_D6";
	case 1245:
		return "NOTE_Ds6";
	case 1319:
		return "NOTE_E6";
	case 1397:
		return "NOTE_F6";
	case 1480:
		return "NOTE_Fs6";
	case 1568:
		return "NOTE_G6";
	case 1661:
		return "NOTE_Gs6";
	case 1760:
		return "NOTE_A6";
	case 1865:
		return "NOTE_As6";
	case 1976:
		return "NOTE_B6";
	default:
		return NULL;
	}
}

static const char *get_duty_cycle_macro(uint8_t duty)
{
	switch (duty) {
	case 0:
		return "0";
	case 64:
		return "UINT8_MAX / 4";
	case 85:
		return "UINT8_MAX / 3";
	case 128:
		return "UINT8_MAX / 2";
	case 170:
		return "UINT8_MAX * 2 / 3";
	case 192:
		return "UINT8_MAX * 3 / 4";
	case 255:
		return "UINT8_MAX";
	default:
		return NULL;
	}
}

static uint32_t calculate_song_length_ms(const struct sequencer *sequencer)
{
	uint32_t max_end_time = 0;

	for (uint32_t i = 0; i < sequencer->note_count; i++) {
		const struct note *note = &sequencer->notes[i];
		uint32_t end_time = note->time_ms + (uint32_t)note->params.duration_ms;

		if (end_time > max_end_time) {
			max_end_time = end_time;
		}
	}

	return max_end_time > 0 ? max_end_time : 1000;
}

static void extract_section_name(const char *filepath, char *name, size_t name_size)
{
	const char *last_slash = strrchr(filepath, '/');
	if (!last_slash) {
		last_slash = strrchr(filepath, '\\');
	}

	const char *basename = last_slash ? last_slash + 1 : filepath;

	const char *last_dot = strrchr(basename, '.');
	size_t len = last_dot ? (size_t)(last_dot - basename) : strlen(basename);

	if (len >= name_size) {
		len = name_size - 1;
	}

	for (size_t i = 0; i < len; i++) {
		char c = basename[i];
		if (isalnum(c)) {
			name[i] = toupper(c);
		} else {
			name[i] = '_';
		}
	}
	name[len] = '\0';
}

bool c_exporter_export_to_file(const struct sequencer *sequencer, const char *filepath)
{
	if (!sequencer || !filepath) {
		fprintf(stderr, "Invalid parameters for C export\n");
		return false;
	}

	char section_name[128];
	extract_section_name(filepath, section_name, sizeof(section_name));

	FILE *file = fopen(filepath, "w");
	if (!file) {
		fprintf(stderr, "Failed to open file for C export: %s\n", filepath);
		return false;
	}

	uint32_t length_ms = calculate_song_length_ms(sequencer);

	fprintf(file, "// Auto-generated by audio-composer\n");
	fprintf(file, "// Total notes: %u\n", sequencer->note_count);
	fprintf(file, "// Duration: %ums\n\n", length_ms);

	fprintf(file, "#include \"music.h\"\n");
	fprintf(file, "#include \"audio.h\"\n\n");

	fprintf(file, "static const struct audio_out_note %s_NOTES[] = {\n", section_name);

	for (uint32_t i = 0; i < sequencer->note_count; i++) {
		const struct note *note = &sequencer->notes[i];
		const struct note_params *params = &note->params;

		fprintf(file, "\t{\n");
		fprintf(file, "\t\t.v = %d,\n", params->voice_index);
		fprintf(file, "\t\t.ms = %u,\n", note->time_ms);
		fprintf(file, "\t\t.spec = {\n");
		fprintf(file, "\t\t\t.callback = NULL,\n");

		const char *note_macro = get_note_macro(params->frequency);
		if (note_macro) {
			fprintf(file, "\t\t\t.frequency_hz = %s,\n", note_macro);
		} else {
			fprintf(file, "\t\t\t.frequency_hz = %d,\n", (int)params->frequency);
		}

		fprintf(file, "\t\t\t.duration_ms = %d,\n", (int)params->duration_ms);

		int16_t scaled_decay = params->decay;
		if (params->waveform == WAVEFORM_NES_NOISE && params->decay != 0) {
			scaled_decay = (int16_t)(params->decay / 1000);
			if (scaled_decay == 0 && params->decay != 0) {
				scaled_decay = params->decay > 0 ? 1 : -1;
			}
		}
		fprintf(file, "\t\t\t.decay = %d,\n", scaled_decay);

		fprintf(file, "\t\t\t.phase = 0,\n");

		int8_t amplitude = params->amplitude_dbfs;
		if (params->waveform == WAVEFORM_NES_NOISE) {
			amplitude = -42;
		}
		amplitude = amplitude > 0 ? 0 : amplitude;

		fprintf(file, "\t\t\t.amplitude_dBFS = %d,\n", amplitude);
		fprintf(file, "\t\t\t.restart = %s,\n", params->restart_phase ? "true" : "false");
		fprintf(file, "\t\t\t.type = %s,\n", waveform_to_audio_out_type(params->waveform));

		switch (params->waveform) {
		case WAVEFORM_SQUARE: {
			const char *duty_macro = get_duty_cycle_macro(params->duty_cycle);
			if (duty_macro) {
				fprintf(file, "\t\t\t.square.duty_cycle = %s,\n", duty_macro);
			} else {
				fprintf(file,
					"\t\t\t.square.duty_cycle = %u,\n",
					params->duty_cycle);
			}
			break;
		}
		case WAVEFORM_NES_NOISE:
			fprintf(file,
				"\t\t\t.nes_noise.lfsr_val = 0x%04X,\n",
				params->nes_noise_lfsr_init);
			fprintf(file,
				"\t\t\t.nes_noise.mode_flag = %s,\n",
				params->nes_noise_mode_flag ? "true" : "false");
			break;
		default:
			break;
		}

		fprintf(file, "\t\t}\n");
		fprintf(file, "\t},\n");
	}

	fprintf(file, "\t{\n");
	fprintf(file, "\t\t.ms = %u,\n", length_ms);
	fprintf(file, "\t\t.spec = {\n");
	fprintf(file, "\t\t\t.type = AUDIO_OUT_TYPE_NONE,\n");
	fprintf(file, "\t\t}\n");
	fprintf(file, "\t}\n");
	fprintf(file, "};\n\n");

	fprintf(file, "static const struct audio_out_section %s = {\n", section_name);
	fprintf(file, "\t.length = ARRAY_SIZE(%s_NOTES),\n", section_name);
	fprintf(file, "\t.notes = %s_NOTES,\n", section_name);
	fprintf(file, "\t.next = NULL,\n");
	fprintf(file, "};\n");

	fclose(file);

	printf("Exported %u notes to C file: %s\n", sequencer->note_count, filepath);
	return true;
}
